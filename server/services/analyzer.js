const { getAllSnapshotsForAnalysis } = require('../db/snapshots');
const { getProfile } = require('../db/profile');
const { getMonitoredEntities, getEntityStats } = require('../db/entities');
const { addDigest, getLatestDigest } = require('../db/digests');
const { getAddonHealthReport, getAutomationHealthReport, getIntegrationHealthReport, getLogHealthReport } = require('./homeassistant');
const { getBatteryPredictions } = require('./predictions');
const { getDismissedWarnings } = require('../db/dismissed');

const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';

/**
 * Generate a daily digest using Gemini AI
 */
async function generateDigest(type = 'daily') {
    const apiKey = process.env.GEMINI_API_KEY;

    if (!apiKey) {
        throw new Error('GEMINI_API_KEY not configured');
    }

    // Gather context
    const profile = getProfile();
    const entities = getMonitoredEntities().filter(e => e.priority !== 'ignore');
    const entityStats = getEntityStats();

    // Get snapshot data for the last 24 hours (or 7 days for weekly)
    const now = new Date();
    const hoursBack = type === 'weekly' ? 168 : 24;
    const startTime = new Date(now.getTime() - hoursBack * 60 * 60 * 1000).toISOString();
    const endTime = now.toISOString();

    const snapshots = getAllSnapshotsForAnalysis(startTime, endTime);

    // Fetch add-on health report
    let addonReport = null;
    try {
        addonReport = await getAddonHealthReport();
        console.log(`[Digest] Add-on report: ${addonReport.total} add-ons, ${addonReport.running} running, ${addonReport.issues.length} issues`);
    } catch (error) {
        console.error('[Digest] Failed to get add-on report:', error.message);
    }

    // Fetch automation health report
    let automationReport = null;
    try {
        automationReport = await getAutomationHealthReport();
        console.log(`[Digest] Automation report: ${automationReport.total} automations, ${automationReport.enabled} enabled, ${automationReport.issues.length} issues`);
    } catch (error) {
        console.error('[Digest] Failed to get automation report:', error.message);
    }

    // Fetch integration health report
    let integrationReport = null;
    try {
        integrationReport = await getIntegrationHealthReport();
        console.log(`[Digest] Integration report: ${integrationReport.total} integrations, ${integrationReport.failed} failed`);
    } catch (error) {
        console.error('[Digest] Failed to get integration report:', error.message);
    }

    // Fetch battery predictions
    let batteryPredictions = [];
    try {
        batteryPredictions = await getBatteryPredictions();
        console.log(`[Digest] Battery predictions: ${batteryPredictions.length} batteries tracked`);
    } catch (error) {
        console.error('[Digest] Failed to get battery predictions:', error.message);
    }

    // Fetch log health report
    let logReport = null;
    try {
        logReport = await getLogHealthReport();
        console.log(`[Digest] Log report: ${logReport.errors.length} errors, ${logReport.warnings.length} warnings`);
    } catch (error) {
        console.error('[Digest] Failed to get log report:', error.message);
    }

    // Get dismissed warnings to filter from output
    const dismissedWarnings = getDismissedWarnings();
    console.log(`[Digest] ${dismissedWarnings.length} dismissed warnings to filter`);

    // Build the prompt
    const prompt = buildAnalysisPrompt(profile, entities, entityStats, snapshots, type, addonReport, automationReport, integrationReport, batteryPredictions, dismissedWarnings, logReport);

    // Call Gemini API
    const response = await fetch(`${GEMINI_API_URL}?key=${apiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            contents: [{
                parts: [{ text: prompt }]
            }],
            generationConfig: {
                temperature: 0.4, // Lower temperature for more consistent JSON
                maxOutputTokens: 8192,
                topP: 0.9,
                responseMimeType: "application/json" // Force JSON mode
            }
        })
    });

    if (!response.ok) {
        const error = await response.text();
        throw new Error(`Gemini API error: ${response.status} - ${error}`);
    }

    const result = await response.json();
    const content = result.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!content) {
        throw new Error('No content generated by Gemini');
    }

    // Parse the JSON response
    let parsedContent;
    try {
        parsedContent = JSON.parse(content);
    } catch (e) {
        console.error('Failed to parse Gemini JSON:', content);
        throw new Error('Gemini returned invalid JSON');
    }

    // extract summary and count for DB headers
    const summary = parsedContent.summary || 'Daily Digest generated';
    const attentionCount = parsedContent.attention_items ? parsedContent.attention_items.length : 0;

    // Store the digest (storing the raw JSON string as content)
    const digestId = addDigest(type, JSON.stringify(parsedContent), summary, attentionCount);

    return {
        id: digestId,
        type,
        content: JSON.stringify(parsedContent),
        summary,
        attentionCount,
        generatedAt: now.toISOString()
    };
}

/**
 * Build the analysis prompt for Gemini
 */
function buildAnalysisPrompt(profile, entities, entityStats, snapshots, type, addonReport = null, automationReport = null, integrationReport = null, batteryPredictions = [], dismissedWarnings = [], logReport = null) {
    const periodLabel = type === 'weekly' ? 'past week' : 'past 24 hours';

    // Detect first-run scenario (no snapshot data yet)
    const isFirstRun = snapshots.length === 0;

    // Group snapshots by entity for analysis
    const entityData = {};
    for (const snap of snapshots) {
        if (!entityData[snap.entity_id]) {
            entityData[snap.entity_id] = {
                friendly_name: snap.friendly_name,
                category: snap.category,
                priority: snap.priority,
                values: []
            };
        }
        entityData[snap.entity_id].values.push({
            timestamp: snap.timestamp,
            value: snap.value_num !== null ? snap.value_num : snap.value_str
        });
    }

    // Build entity summary for the prompt
    const entitySummaries = Object.entries(entityData).map(([entityId, data]) => {
        const values = data.values;
        if (values.length === 0) return null;

        // For numeric values, calculate stats
        const numericValues = values.filter(v => typeof v.value === 'number').map(v => v.value);
        let stats = '';

        if (numericValues.length > 0) {
            const min = Math.min(...numericValues);
            const max = Math.max(...numericValues);
            const avg = numericValues.reduce((a, b) => a + b, 0) / numericValues.length;
            stats = `min: ${min.toFixed(1)}, max: ${max.toFixed(1)}, avg: ${avg.toFixed(1)}`;
        } else {
            // For state values, show unique states
            const uniqueStates = [...new Set(values.map(v => v.value))];
            stats = `states: ${uniqueStates.join(', ')}`;
        }

        return `- ${data.friendly_name} (${data.category}, ${data.priority}): ${stats}`;
    }).filter(Boolean);

    // Build add-on summary
    let addonSection = '';
    if (addonReport && addonReport.total > 0) {
        const addonSummary = [
            `Total: ${addonReport.total} add-ons (${addonReport.running} running, ${addonReport.stopped} stopped)`,
            addonReport.updateAvailable > 0 ? `Updates available: ${addonReport.updateAvailable}` : null,
            ...addonReport.issues.map(i => `- ⚠️ ${i.addon}: ${i.issue}`)
        ].filter(Boolean);

        addonSection = `
## Add-on Status
${addonSummary.join('\n')}
`;
    }

    // Build automation summary
    let automationSection = '';
    if (automationReport && automationReport.total > 0) {
        const autoSummary = [
            `Total: ${automationReport.total} automations (${automationReport.enabled} enabled, ${automationReport.disabled} disabled)`,
            ...automationReport.issues.slice(0, 5).map(i => `- ${i.name}: ${i.issue}`)
        ].filter(Boolean);

        automationSection = `
## Automation Health
${autoSummary.join('\n')}
`;
    }

    // Build integration summary  
    let integrationSection = '';
    if (integrationReport && integrationReport.issues.length > 0) {
        const intSummary = [
            `${integrationReport.failed} of ${integrationReport.total} integrations have issues:`,
            ...integrationReport.issues.map(i => `- ${i.name} (${i.domain}): ${i.issue}`)
        ];

        integrationSection = `
## Integration Issues
${intSummary.join('\n')}
`;
    }

    // Build battery predictions section
    let batterySection = '';
    if (batteryPredictions.length > 0) {
        const batteryLines = batteryPredictions.map(b => {
            const warning = b.needs_attention ? ' ⚠️ NEEDS ATTENTION' : '';
            return `- ${b.friendly_name}: ${b.current_level}% (draining ~${b.drain_rate_per_day}%/day, ~${b.days_remaining} days remaining)${warning}`;
        });

        batterySection = `
## Battery Predictions
${batteryLines.join('\n')}
`;
    }

    // Build log analysis section
    let logSection = '';
    if (logReport && logReport.analyzed) {
        const logLines = [];
        if (logReport.errors.length > 0) {
            logLines.push(`### Recent Errors (${logReport.errors.length})`);
            logReport.errors.slice(0, 5).forEach(e => {
                logLines.push(`- [${e.source}] ${e.message}`);
            });
        }
        if (logReport.warnings.length > 0) {
            logLines.push(`### Recent Warnings (${logReport.warnings.length})`);
            logReport.warnings.slice(0, 5).forEach(w => {
                logLines.push(`- [${w.source}] ${w.message}`);
            });
        }
        if (logLines.length > 0) {
            logSection = `
## Recent Log Issues
${logLines.join('\n')}
`;
        } else {
            logSection = `
## Logs
No significant errors or warnings found in recent logs.
`;
        }
    }

    // First-run specific instructions
    const firstRunInstructions = isFirstRun ? `
## IMPORTANT: First Run Scenario
This is the user's FIRST digest - they just set up the system. There is no snapshot data yet because data collection just started.

DO NOT treat this as an error or critical issue. Instead:
- Be welcoming and congratulate them on setting up
- Explain that data collection has begun and meaningful analysis will be available in the next digest
- Focus on the positive aspects of their setup (entities discovered, profile configured)
- Give a helpful tip about what to expect

The summary should be encouraging, like: "Welcome! Your smart home monitoring is now active. Check back tomorrow for your first full health report."
` : '';

    const prompt = `You are a smart home health analyst for Home Assistant. Analyze the provided data and return a JSON object.
${firstRunInstructions}
## Home Profile
${profile.occupants ? `- Occupants: ${JSON.stringify(profile.occupants)}` : '- Occupants: Not specified'}
${profile.schedule ? `- Schedule: ${JSON.stringify(profile.schedule)}` : '- Schedule: Not specified'}
${profile.priorities ? `- Priorities: ${JSON.stringify(profile.priorities)}` : '- Priorities: Not specified'}
${profile.concerns ? `- Concerns: ${profile.concerns}` : ''}

## Entity Overview
Total monitored: ${entities.length} entities across ${entityStats.length} categories
${addonSection}${automationSection}${integrationSection}${batterySection}${logSection}
## Data from ${periodLabel}
${entitySummaries.length > 0 ? entitySummaries.join('\\n') : 'No snapshot data available yet - this is expected for a new setup.'}

## Your Task
Analyze the data and return a JSON object with the following structure:

{
  "summary": "A concise one-sentence summary of the home's health.",
  "attention_items": [
    {
      "title": "Short title of issue",
      "description": "Brief explanation of why this is a concern (1-2 sentences).",
      "severity": "critical" | "warning",
      "detailed_info": {
        "explanation": "More detailed explanation of what's happening and why it matters.",
        "affected_entities": ["entity.id_1", "entity.id_2"],
        "suggestions": ["First suggestion to fix", "Second suggestion"],
        "troubleshooting": "Step-by-step troubleshooting guidance if applicable."
      }
    }
  ],
  "observations": [
    {
      "title": "Short title",
      "description": "Interesting pattern or trend noticed.",
      "trend": "improving" | "stable" | "degrading"
    }
  ],
  "positives": [
    "List of things working well",
    "List of normal patterns"
  ],
  "tip": "One actionable tip for the user."
}

Ensure the "attention_items" array is empty if there are no issues. Be VERY strict about what constitutes an issue:
- Batteries above 30% are FINE - do not flag as warnings
- Normal operating conditions are not issues - only flag actual malfunctions or critical thresholds
- Don't be alarmist about minor variations or things that are "lower than others" but still healthy
- Only include attention_items for things that genuinely need user action NOW
${dismissedWarnings.length > 0 ? `
## DISMISSED WARNINGS - DO NOT INCLUDE THESE:
The user has dismissed the following warnings. DO NOT include any attention_items with these titles or similar topics:
${dismissedWarnings.map(d => `- "${d.title}"`).join('\n')}
` : ''}
${isFirstRun ? 'Since this is the first run with no data yet, attention_items should be EMPTY and the tone should be welcoming.' : ''}
Do NOT include markdown formatting in the JSON. Return ONLY raw JSON.`;

    return prompt;
}

/**
 * Parse the Gemini response to extract structured data
 * Not needed for JSON mode, but kept for compatibility handling if we switch back
 */
function parseDigestResponse(content) {
    return { summary: 'Legacy digest', attentionCount: 0 };
}

/**
 * Get the current digest status
 */
function getDigestStatus() {
    const latest = getLatestDigest();
    const digestTime = process.env.DIGEST_TIME || '07:00';

    // Calculate next digest time
    const now = new Date();
    const [hours, minutes] = digestTime.split(':').map(Number);
    const nextDigest = new Date(now);
    nextDigest.setHours(hours, minutes, 0, 0);

    if (nextDigest <= now) {
        nextDigest.setDate(nextDigest.getDate() + 1);
    }

    return {
        lastDigest: latest ? {
            id: latest.id,
            timestamp: latest.timestamp,
            summary: latest.summary,
            attentionCount: latest.attention_count
        } : null,
        nextDigestTime: nextDigest.toISOString(),
        digestTimeConfig: digestTime,
        apiConfigured: !!process.env.GEMINI_API_KEY
    };
}

module.exports = {
    generateDigest,
    getDigestStatus
};

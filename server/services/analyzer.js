const { getAllSnapshotsForAnalysis } = require('../db/snapshots');
const { getProfile } = require('../db/profile');
const { getMonitoredEntities, getEntityStats } = require('../db/entities');
const { addDigest, getLatestDigest } = require('../db/digests');

const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';

/**
 * Generate a daily digest using Gemini AI
 */
async function generateDigest(type = 'daily') {
    const apiKey = process.env.GEMINI_API_KEY;

    if (!apiKey) {
        throw new Error('GEMINI_API_KEY not configured');
    }

    // Gather context
    const profile = getProfile();
    const entities = getMonitoredEntities().filter(e => e.priority !== 'ignore');
    const entityStats = getEntityStats();

    // Get snapshot data for the last 24 hours (or 7 days for weekly)
    const now = new Date();
    const hoursBack = type === 'weekly' ? 168 : 24;
    const startTime = new Date(now.getTime() - hoursBack * 60 * 60 * 1000).toISOString();
    const endTime = now.toISOString();

    const snapshots = getAllSnapshotsForAnalysis(startTime, endTime);

    // Build the prompt
    const prompt = buildAnalysisPrompt(profile, entities, entityStats, snapshots, type);

    // Call Gemini API
    const response = await fetch(`${GEMINI_API_URL}?key=${apiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            contents: [{
                parts: [{ text: prompt }]
            }],
            generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 2048,
                topP: 0.9
            }
        })
    });

    if (!response.ok) {
        const error = await response.text();
        throw new Error(`Gemini API error: ${response.status} - ${error}`);
    }

    const result = await response.json();
    const content = result.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!content) {
        throw new Error('No content generated by Gemini');
    }

    // Parse the response to extract summary and attention count
    const parsed = parseDigestResponse(content);

    // Store the digest
    const digestId = addDigest(type, content, parsed.summary, parsed.attentionCount);

    return {
        id: digestId,
        type,
        content,
        summary: parsed.summary,
        attentionCount: parsed.attentionCount,
        generatedAt: now.toISOString()
    };
}

/**
 * Build the analysis prompt for Gemini
 */
function buildAnalysisPrompt(profile, entities, entityStats, snapshots, type) {
    const periodLabel = type === 'weekly' ? 'past week' : 'past 24 hours';

    // Group snapshots by entity for analysis
    const entityData = {};
    for (const snap of snapshots) {
        if (!entityData[snap.entity_id]) {
            entityData[snap.entity_id] = {
                friendly_name: snap.friendly_name,
                category: snap.category,
                priority: snap.priority,
                values: []
            };
        }
        entityData[snap.entity_id].values.push({
            timestamp: snap.timestamp,
            value: snap.value_num !== null ? snap.value_num : snap.value_str
        });
    }

    // Build entity summary for the prompt
    const entitySummaries = Object.entries(entityData).map(([entityId, data]) => {
        const values = data.values;
        if (values.length === 0) return null;

        // For numeric values, calculate stats
        const numericValues = values.filter(v => typeof v.value === 'number').map(v => v.value);
        let stats = '';

        if (numericValues.length > 0) {
            const min = Math.min(...numericValues);
            const max = Math.max(...numericValues);
            const avg = numericValues.reduce((a, b) => a + b, 0) / numericValues.length;
            stats = `min: ${min.toFixed(1)}, max: ${max.toFixed(1)}, avg: ${avg.toFixed(1)}`;
        } else {
            // For state values, show unique states
            const uniqueStates = [...new Set(values.map(v => v.value))];
            stats = `states: ${uniqueStates.join(', ')}`;
        }

        return `- ${data.friendly_name} (${data.category}, ${data.priority}): ${stats}`;
    }).filter(Boolean);

    const prompt = `You are a smart home health analyst for Home Assistant. Generate a concise daily digest.

## Home Profile
${profile.occupants ? `- Occupants: ${JSON.stringify(profile.occupants)}` : '- Occupants: Not specified'}
${profile.schedule ? `- Schedule: ${JSON.stringify(profile.schedule)}` : '- Schedule: Not specified'}
${profile.priorities ? `- Priorities: ${JSON.stringify(profile.priorities)}` : '- Priorities: Not specified'}
${profile.concerns ? `- Concerns: ${profile.concerns}` : ''}

## Entity Overview
Total monitored: ${entities.length} entities across ${entityStats.length} categories

## Data from ${periodLabel}
${entitySummaries.length > 0 ? entitySummaries.join('\n') : 'No snapshot data available yet.'}

## Your Task
Generate a friendly, helpful digest that:
1. **Highlights anything unusual** - deviations from normal patterns, unexpected states
2. **Notes items needing attention** - maintenance reminders, batteries, offline devices
3. **Provides comfort insights** - temperature trends, energy usage patterns
4. **Keeps it concise** - max 3-5 key points, prioritize what matters most

Format your response as:

## ğŸ  Daily Digest - [Date]

### âš ï¸ Needs Attention ([count] items)
- Item 1
- Item 2

### ğŸ“Š Notable Observations
- Observation 1
- Observation 2

### âœ… All Good
- What's working well

### ğŸ’¡ Tip of the Day
One actionable suggestion based on the data.

---
**Summary:** [One-line summary for notifications]

If there's no data yet, provide a friendly "getting started" message explaining what the user will see once data collection begins.`;

    return prompt;
}

/**
 * Parse the Gemini response to extract structured data
 */
function parseDigestResponse(content) {
    // Extract attention count from the "Needs Attention" section
    const attentionMatch = content.match(/Needs Attention \((\d+) items?\)/i);
    const attentionCount = attentionMatch ? parseInt(attentionMatch[1]) : 0;

    // Extract summary from the end
    const summaryMatch = content.match(/\*\*Summary:\*\*\s*(.+?)(?:\n|$)/i);
    const summary = summaryMatch
        ? summaryMatch[1].trim()
        : 'Daily smart home digest generated';

    return { summary, attentionCount };
}

/**
 * Get the current digest status
 */
function getDigestStatus() {
    const latest = getLatestDigest();
    const digestTime = process.env.DIGEST_TIME || '07:00';

    // Calculate next digest time
    const now = new Date();
    const [hours, minutes] = digestTime.split(':').map(Number);
    const nextDigest = new Date(now);
    nextDigest.setHours(hours, minutes, 0, 0);

    if (nextDigest <= now) {
        nextDigest.setDate(nextDigest.getDate() + 1);
    }

    return {
        lastDigest: latest ? {
            id: latest.id,
            timestamp: latest.timestamp,
            summary: latest.summary,
            attentionCount: latest.attention_count
        } : null,
        nextDigestTime: nextDigest.toISOString(),
        digestTimeConfig: digestTime,
        apiConfigured: !!process.env.GEMINI_API_KEY
    };
}

module.exports = {
    generateDigest,
    getDigestStatus
};

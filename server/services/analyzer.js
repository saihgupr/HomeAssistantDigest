const { getAllSnapshotsForAnalysis } = require('../db/snapshots');
const { getProfile } = require('../db/profile');
const { getMonitoredEntities, getEntityStats } = require('../db/entities');
const { addDigest, getLatestDigest } = require('../db/digests');

const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';

/**
 * Generate a daily digest using Gemini AI
 */
async function generateDigest(type = 'daily') {
    const apiKey = process.env.GEMINI_API_KEY;

    if (!apiKey) {
        throw new Error('GEMINI_API_KEY not configured');
    }

    // Gather context
    const profile = getProfile();
    const entities = getMonitoredEntities().filter(e => e.priority !== 'ignore');
    const entityStats = getEntityStats();

    // Get snapshot data for the last 24 hours (or 7 days for weekly)
    const now = new Date();
    const hoursBack = type === 'weekly' ? 168 : 24;
    const startTime = new Date(now.getTime() - hoursBack * 60 * 60 * 1000).toISOString();
    const endTime = now.toISOString();

    const snapshots = getAllSnapshotsForAnalysis(startTime, endTime);

    // Build the prompt
    const prompt = buildAnalysisPrompt(profile, entities, entityStats, snapshots, type);

    // Call Gemini API
    const response = await fetch(`${GEMINI_API_URL}?key=${apiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            contents: [{
                parts: [{ text: prompt }]
            }],
            generationConfig: {
                temperature: 0.4, // Lower temperature for more consistent JSON
                maxOutputTokens: 4096,
                topP: 0.9,
                responseMimeType: "application/json" // Force JSON mode
            }
        })
    });

    if (!response.ok) {
        const error = await response.text();
        throw new Error(`Gemini API error: ${response.status} - ${error}`);
    }

    const result = await response.json();
    const content = result.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!content) {
        throw new Error('No content generated by Gemini');
    }

    // Parse the JSON response
    let parsedContent;
    try {
        parsedContent = JSON.parse(content);
    } catch (e) {
        console.error('Failed to parse Gemini JSON:', content);
        throw new Error('Gemini returned invalid JSON');
    }

    // extract summary and count for DB headers
    const summary = parsedContent.summary || 'Daily Digest generated';
    const attentionCount = parsedContent.attention_items ? parsedContent.attention_items.length : 0;

    // Store the digest (storing the raw JSON string as content)
    const digestId = addDigest(type, JSON.stringify(parsedContent), summary, attentionCount);

    return {
        id: digestId,
        type,
        content: JSON.stringify(parsedContent),
        summary,
        attentionCount,
        generatedAt: now.toISOString()
    };
}

/**
 * Build the analysis prompt for Gemini
 */
function buildAnalysisPrompt(profile, entities, entityStats, snapshots, type) {
    const periodLabel = type === 'weekly' ? 'past week' : 'past 24 hours';

    // Group snapshots by entity for analysis
    const entityData = {};
    for (const snap of snapshots) {
        if (!entityData[snap.entity_id]) {
            entityData[snap.entity_id] = {
                friendly_name: snap.friendly_name,
                category: snap.category,
                priority: snap.priority,
                values: []
            };
        }
        entityData[snap.entity_id].values.push({
            timestamp: snap.timestamp,
            value: snap.value_num !== null ? snap.value_num : snap.value_str
        });
    }

    // Build entity summary for the prompt
    const entitySummaries = Object.entries(entityData).map(([entityId, data]) => {
        const values = data.values;
        if (values.length === 0) return null;

        // For numeric values, calculate stats
        const numericValues = values.filter(v => typeof v.value === 'number').map(v => v.value);
        let stats = '';

        if (numericValues.length > 0) {
            const min = Math.min(...numericValues);
            const max = Math.max(...numericValues);
            const avg = numericValues.reduce((a, b) => a + b, 0) / numericValues.length;
            stats = `min: ${min.toFixed(1)}, max: ${max.toFixed(1)}, avg: ${avg.toFixed(1)}`;
        } else {
            // For state values, show unique states
            const uniqueStates = [...new Set(values.map(v => v.value))];
            stats = `states: ${uniqueStates.join(', ')}`;
        }

        return `- ${data.friendly_name} (${data.category}, ${data.priority}): ${stats}`;
    }).filter(Boolean);

    const prompt = `You are a smart home health analyst for Home Assistant. Analyze the provided data and return a JSON object.

## Home Profile
${profile.occupants ? `- Occupants: ${JSON.stringify(profile.occupants)}` : '- Occupants: Not specified'}
${profile.schedule ? `- Schedule: ${JSON.stringify(profile.schedule)}` : '- Schedule: Not specified'}
${profile.priorities ? `- Priorities: ${JSON.stringify(profile.priorities)}` : '- Priorities: Not specified'}
${profile.concerns ? `- Concerns: ${profile.concerns}` : ''}

## Entity Overview
Total monitored: ${entities.length} entities across ${entityStats.length} categories

## Data from ${periodLabel}
${entitySummaries.length > 0 ? entitySummaries.join('\n') : 'No snapshot data available yet.'}

## Your Task
Analyze the data and return a JSON object with the following structure:

{
  "summary": "A concise one-sentence summary of the home's health.",
  "attention_items": [
    {
      "title": "Short title of issue",
      "description": "Detailed explanation of why this is a concern.",
      "severity": "critical" | "warning"
    }
  ],
  "observations": [
    {
      "title": "Short title",
      "description": "Interesting pattern or trend noticed.",
      "trend": "improving" | "stable" | "degrading"
    }
  ],
  "positives": [
    "List of things working well",
    "List of normal patterns"
  ],
  "tip": "One actionable tip for the user."
}

Ensure the "attention_items" array is empty if there are no issues. Be strict about what constitutes an issue.
Do NOT include markdown formatting in the JSON. Return ONLY raw JSON.`;

    return prompt;
}

/**
 * Parse the Gemini response to extract structured data
 * Not needed for JSON mode, but kept for compatibility handling if we switch back
 */
function parseDigestResponse(content) {
    return { summary: 'Legacy digest', attentionCount: 0 };
}

/**
 * Get the current digest status
 */
function getDigestStatus() {
    const latest = getLatestDigest();
    const digestTime = process.env.DIGEST_TIME || '07:00';

    // Calculate next digest time
    const now = new Date();
    const [hours, minutes] = digestTime.split(':').map(Number);
    const nextDigest = new Date(now);
    nextDigest.setHours(hours, minutes, 0, 0);

    if (nextDigest <= now) {
        nextDigest.setDate(nextDigest.getDate() + 1);
    }

    return {
        lastDigest: latest ? {
            id: latest.id,
            timestamp: latest.timestamp,
            summary: latest.summary,
            attentionCount: latest.attention_count
        } : null,
        nextDigestTime: nextDigest.toISOString(),
        digestTimeConfig: digestTime,
        apiConfigured: !!process.env.GEMINI_API_KEY
    };
}

module.exports = {
    generateDigest,
    getDigestStatus
};
